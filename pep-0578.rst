PEP: 578
Title: Explicit target scopes for inline assignments
Author: Nick Coghlan <ncoghlan@gmail.com>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Created: 17-Jun-2018
Python-Version: 3.8
Post-History: 22-May-2018


Abstract
========

This is a competing proposal to PEP 572 that retains the same syntax and
semantics for names that are already defined as being local to a regular block
scope, but proposes different syntax and semantics for the following cases:

* assignments to target names that are not otherwise declared as being local
  to the current block scope
* assignments to target names inside scoped expressions (whether lambda
  expressions, generator expressions, or comprehensions)

Two major design elements are added in this proposal relative to PEP 572.

Firstly, a new compile time ``TargetNameError`` is added as a subclass of
``SyntaxError`` to handle cases where it is deemed to be unclear which target
scope is expected to be modified by an inline assignment.

For example, the following code would raise ``TargetNameError``::

    x := 1

Secondly, a new optional ``given`` clause is added to several constructs to
allow developers to explicitly declare the intended target scope of the name.
For example, the assignment statements in this example::

    x = get_value()
    while x:
        ...
        x = get_value()

would be equivalent to the following inline assignment and scope declaration::

    while x := get_value() given x:
        ...

Note that this PEP is only a partial competitor to PEP 572, in that if that
PEP is ultimately rejected, then this PEP would also be considered rejected. See
`Relationship with PEP 572`_ for more details on the connections between
the two PEPs.


Syntax and semantics
====================

Block scopes and scoped expressions
-----------------------------------

To help simplify the description of the intended semantics, this PEP introduces
two new terms for describing Python scopes:

* "block scope": a module, class, or function scope. Block scopes will typically
  cover several statements, and may include complex control flow statements
  with one or more nested suites.
* "scoped expression": a lambda expression, generator expression, or container
  comprehension, which defines a new execution scope either to hide local name
  bindings (container comprehensions), or else to hide local name bindings and
  also to enable delayed evaluation (lamdba expressions and generator expressions)


Removing implicit scope declarations from inline assignments
------------------------------------------------------------

PEP 572 proposes the following implicit scoping semantics for assignment
expressions:

* at block scope, ``NAME := EXPR`` implicitly declares ``NAME`` to be a local
  variable, the same way ``NAME = EXPR`` does, but ``NAME := EXPR`` is prohibited
  as a top level expression (it must be written ``(NAME := EXPR)`` instead)
* in lambda expressions, ``NAME := EXPR`` implicitly declares ``NAME`` to be
  a local variable, just as it does at block scope
* in other scoped expressions, ``NAME := EXPR`` implicitly declares ``NAME`` to
  be local to the nearest containing block scope or lambda expression

This PEP instead proposes to handle inline assignment target names as follows:

* at module and class scope, ``NAME := EXPR`` implicitly declares ``NAME`` to be
  local to the current scope (as it does in PEP 572 - this is a design constraint
  imposed by the fact that the compiler doesn't have full compile time visibility
  into the names defined in these scopes).
* at function scope, ``NAME := EXPR`` is only permitted if the target scope of
  ``NAME`` has previously been declared as being local, nonlocal, or global.
  Assignments to undeclared names will raise ``TargetNameError``.
* in scoped expressions (including lambda expressions), ``NAME := EXPR`` is only
  permitted if the target scope of ``NAME`` has previously been declared as being
  local, nonlocal, or global. Assignments to undeclared names will raise
  ``TargetNameError``. Assignments to comprehension and generation expression
  iteration variables will also raise ``TargetNameError``.

These changes mean PEP 572's restriction against top-level assignment
expressions in block scopes can be dropped, as the fact that ``NAME = EXPR``
implicitly declares a new function local while ``NAME := EXPR`` doesn't should
provide sufficient incentive for developers to stick with the traditional
top-level assignment statement in the cases where it applies.

(Note: this proposed change is a direct application of PEP 20's admonition
"In the face of ambiguity, refuse the temptation to guess". It doesn't rule
out changing our minds later and deciding that some of these cases are
sufficiently unambiguous that it's OK to make the most common desired behaviour
implicit, but in the meantime, it means that readers unfamiliar with the new
syntax will receive more hints as to what's happening at compile time and at
runtime)


Adding explicit inline scope declarations
-----------------------------------------

Removing the implicit target scoping rules for inline assignment expressions
has the potential to hinder their intended benefits in reducing the amount of
vertical screen real-estate consumed by a block of code.

To quote an example from PEP 572, Python developers can already write::

    match = re.match(data)
    group = match.group(1) if match else None

This means that if a developer would currently be inclined to save a line by
writing this code using the less efficient form::

    group = re.match(data).group(1) if re.match(data) else None

They're not likely to find either of the following an attractive alternative to
the status quo::

    match = None
    group = match.group(1) if (match := re.match(data)) else None

    match: typing.Match
    group = match.group(1) if (match := re.match(data)) else None

To address this, a new ``given TARGETS`` subclause would be added to selected
constructs, allowing inline declaration of valid target names in the following
cases:

* while loops: ``while EXPR given TARGETS:``
* if statements: ``if EXPR given TARGETS:``
* elif clauses: ``elif EXPR given TARGETS:``
* conditional expressions: ``LHS if COND given TARGETS else RHS``
* lambda expressions: ``lambda ARGSPEC: EXPR given TARGETS``
* as a trailing clause in comprehensions and generator expression:
  ``EXPR for VAR1 in ITER1 for VAR2 in ITER2 given TARGETS``

This would allow the more efficient version of the above code to be written as::

    group = match.group(1) if (match := re.match(data)) given match else None

The ``TARGETS`` subclause would be a new kind of grammar node, permitting the
following forms:

* ``NAME``: simple declaration of a local variable, such that the statement
  ``if NAME := EXPR given NAME: pass`` is roughly equivalent to ``NAME = EXPR``.
* ``nonlocal NAME``: equivalent to a ``nonlocal NAME`` statement.
* ``global NAME``: equivalent to a ``global NAME`` statement.
* ``(NAME [: EXPR] [= EXPR])``: declaration of a name with an optional type
  annotation and initial value (equivalent to a full inline assignment
  statement, but restricted to simple name targets).
* ``(TARGET1, TARGET2, ...)``: a parenthesised sequence of target declarations,
  allowing multiple targets to be declared without requiring multiple ``given``
  clauses.

Scoped expressions (including lambda expressions) would behave the same way as
any other nested function scope: ``... given NAME`` would declare the target
name to be local to the scoped expression, and omitting that declaration would
lead to a compile time ``TargetNameError``.


Postfix keyword semantics
-------------------------

To allow ``given` clauses to be introduced without a ``__future__`` import,
the grammar would be modified to introduce the notion of "postfix keywords":
keywords which can never start a new expression or statements, and hence don't
conflict with the use of such words as regular variable and attribute names.

Sections of the grammar that currently reference the ``NAME`` node directly
would be changed to reference a new ``names_plus: NAME | postfix_keyword``
node instead.

While ``given`` would be the only initial entry under the ``postfix_keyword``
node, other potential candidates for inclusion would be ``as``, ``is``, ``or``,
and ``and``.


Examples
========

Partial sums
------------

PEP 572 requires that partial sums be accumulated in the containing scope. This
PEP instead allows them to be accumulated directly in the implicitly nested
scope by declaring them as an initialised local variable::

    partial_sums = [(total := total + x) for x in values given (total = 0)]


Simplifying list comprehensions
-------------------------------

Examples are from PEP 572, and just need a ``given y`` appended in order to
use a local variable within the implicitly nested scope::

    results = [(x, y, x/y) for x in input_data if (y := f(x)) > 0 given y]

    stuff = [[y := f(x), x/y] for x in range(5) given y]

To bind the name in the containing scope instead, the scope declaration needs to
``given nonlocal y`` or ``given global y`` as appropriate.


Capturing condition values
--------------------------

Examples are from PEP 572, and just need a ``given NAME`` appended in order to
use a local variable within the current scope::

    # Loop-and-a-half
    while (command := input("> ")) != "quit" given command:
        print("You entered:", command)

    # Reading socket data until an empty string is returned
    while data := sock.recv() given data:
        print("Received data:", data)

    # Capturing regular expression match objects
    if match := re.search(pat, text) given match:
        print("Found:", match.group(0))
    elif match := re.search(otherpat, text):
        print("Alternate found:", match.group(0))
    elif match := re.search(third, text):
        print("Fallback found:", match.group(0))

Note that if one of the ``elif`` clauses has a typo in the target name, then
the compiler will typically catch that and raise ``TargetNameError`` (it will
only miss it if the typo results in a different valid name).

If an ``elif`` clause does need to introduce a new name, then it can have its
own ``given` clause (which will make the introduction of the new target name
more obvious to the reader of the code).


Fork
----

An example from the low-level UNIX world::

    if pid := os.fork() given pid:
        # Parent code
    else:
        # Child code


Open Questions
==============


Comprehensions and the outermost iterable clause
------------------------------------------------

Given current comprehension evaluation semantics, the outermost iterable clause
in a comprehension isn't going to be able to see any names defined in the
``given`` clause (since it gets evaluated in containing scope).

However, since the given clause is completely new, the following compilation
rule could be introduced: if a comprehension or generator expression uses a
given clause, then the outermost iterable expression is evaluated inside the
implicitly nested scope, after any given statements have been executed.


Execution of initialisers in while loops
----------------------------------------

The ``given`` clause is comprehensions and generator expressions is only going
to be executed once, before the iterative cycle gets started.

It likely makes sense to use the same principle for the ``while`` statement
header clause, such that the partial sums example maps easily to the ``while``
loop form::

    while (total := total + get_value()) < limit given total = 0:
        ...


Design discussion
=================

Assignment target ambiguity in scoped expressions
-------------------------------------------------

This PEP declares the target for all inline assignments in scoped expressions to
be inherently ambiguous. This ambiguity is best illustrated with container
comprehensions, as there are two quite distinct ways of thinking about those.

The first way matches the way that container comprehensions were first implemented
in Python 2.0: as syntactic sugar for a procedural ``for`` loop. This implementation
approach meant that ``[x for x in iterable]`` was semantically equivalent to::

    _expr_result = []
    for x in iterable:
        _expr_result.append(x)
    # Use _expr_result as the result of the comprehension expression

This semantic equivalence extended to having the iteration variable (``x``
in the example) get set in the containing scope (potentially overwriting a
previously bound value).

The second way matches the way that generator expressions have worked since their
introduction in Python 2.4, and the way that container comprehensions were
updated to work in Python 3.0: as an implicitly defined nested function that
gets called immediately after being defined. This implementation approach (with
PEP 289's refinement to eagerly evaluate the outermost iterable) means that
``[x for x in iterable]`` is semantically equivalent to::

    def _listcomp(outmost_iterable):
        _result = []
        for x in iterable:
            _result.append(x)
        return _result
    _expr_result = _listcomp(iterable)
    # Use _expr_result as the result of the comprehension expression

This execution model explicitly *broke* the semantic equivalence to the ``for``
loop based version, since it keeps the iteration variable from being bound in
the containing scope.

The above means that, as of Python 3.7, the scoping rules for scoped expressions
can all still be defined as "they use the same scoping rules as the equivalent
nested function".

PEP 572 proposes to replace that existing design principle with the following
set of rules:

* lambda expressions continue to use the same scoping rules as nested functions
* container comprehensions go back to behaving like an inline ``for`` loop (with
  all inline assignments affecting the containing scope, including implicit
  declarations of new local variables), *except* that the iteration variable
  remains hidden from the containing scope
* generator expressions start behaving more like an inline ``for`` loop,
  retaining consistency with container comprehensions, but losing consistency
  with lambda expressions

The intent behind this proposal appears to be to promote the ``for`` statement
form as the "correct" way of thinking about comprehensions, and thus views it
as reasonable for inline assignments to behave that way by default, even though
that behaviour will be surprising to anyone that thinks of comprehensions as
being self-contained declarations of a data structure's expected contents.

Unfortunately, PEP 572's proposed approach creates some inconsistencies in the
language where very similar looking code ends up not working due to subtle
differences in order of evaluation.

For example, consider the following data manipulation pipeline::

    stage1 = [f(x) for x in data if f(x)]
    stage2 = [g(x) for x in stage1 if g(x)]

Given PEP 572, a developer may decide to use inline assignment to avoid repeated
execution of the condition expression when calculating the result tuple for each
iteration::

    stage1 = [y for x in data if y := f(x)]
    stage2 = [y for x in stage1 if y := g(x)]

And then they may further decide to make the whole process evaluated on demand
by using generator expressions rather than list comprehensions::

    stage1 = (y for x in data if y := f(x))
    stage2 = (y for x in stage1 if y := g(x))

So far, the fact that ``stage1`` and ``stage2`` are sharing their storage for
``y`` isn't visible without close runtime state introspection, so developers
could be forgiven for assuming that the comprehensions and generator
expressions in the above examples are still self-contained.

Where things would start to go subtly wrong is if the developer:

* also has a local variable named ``y`` that they're using for other purposes
  (even though a local variable named ``x`` would be unaffected)
* attempts to use the ``y`` variable to maintain state between iterations in
  the generator expression version (even though that would work fine in the
  eagerly evaluated list comprehension version)

That is, this code would be correct::

    x = starting_x = object()
    stage1 = [y for x in data if y := f(x)]
    stage2 = [y for x in stage1 if y := g(x)]
    assert x is starting_x # Succeeds due to "x" being private

But this code would be incorrect for any non-empty ``data`` iterable::

    y = starting_y = object()
    stage1 = [y for x in data if y := f(x)]
    stage2 = [y for x in stage1 if y := g(x)]
    assert y is starting_y # Fails due to "y" leaking by default

And similarly, this code would be correct due to the eager iteration::

    tally = 0
    stage1 = [(tally := tally + y) for x in data if y := f(x)]
    tally = 0
    stage2 = [(tally := tally + y) for x in stage1 if y := g(x)]

But the generator form would have to use distinct variable names to maintain
that correctness::

    tally1 = 0
    stage1 = ((tally1 := tally1 + y) for x in data if y := f(x))
    tally2 = 0
    stage2 = ((tally2 := tally2 + y) for x in stage1 if y := g(x))

This PEP instead proposes that we *keep* the simple "scoped expressions use the
same scoping rules as the equivalent nested function", and have them all default
to raising ``TargetNameError`` for undeclared target names.

The example data pipelines above would then need to be written as::

    stage1 = [(x, y) for x in data if y := f(x) given y]
    stage2 = [(x, y) for x in stage1 if y := g(x) given y]

And::

    stage1 = ((x, y) for x in data if y := f(x) given y)
    stage2 = ((x, y) for x in stage1 if y := g(x) given y)

The partial sum pipelines would look like::

    stage1 = [(tally := tally + y) for x in data if y := f(x) given (y, (tally=0))]
    stage2 = [(tally := tally + y) for x in stage1 if y := g(x) given (y, (tally=0))]

And::

    stage1 = ((tally := tally + y) for x in data if y := f(x) given (y, (tally=0)))
    stage2 = ((tally := tally + y) for x in stage1 if y := g(x) given (y, (tally=0)))

If you actually *wanted* the iteration variable or an internal assignment to
leak, then you'd append an appropriate ``nonlocal`` or ``global`` declaration::

    x = None
    stage1 = [y for x in data if y := f(x) given (y, nonlocal x)]
    print("Last accepted stage 1 input:", x)
    stage2 = [(x, y) for x in stage1 if y := g(x) given (y, nonlocal x)]
    print("Last accepted stage 2 input:", x)


Relationship with PEP 572
=========================

The case for allowing inline assignments at all is made in PEP 572. This
competing PEP was initially going to propose an alternate surface syntax
(``EXPR given NAME = EXPR``), while retaining the expression semantics from
PEP 572, but that changed when discussing one of the initial motivating use
cases for allowing embedded assignments at all: making it possible to easily
calculate cumulative sums in comprehensions and generator expressions.

My first attempt at better handling that case became PEP 577, but I decided
I didn't like the consequences of allowing arbitrary inline augmented assignments
(see that PEP's withdrawal notice for details).

This PEP thus represents my second attempt at resolving my concerns with
PEP 572's proposed scoping semantics, and I like it a lot better, especially
as it also directly addresses the partial sum accumulation feature request
without relying on state leaking outside the affected comprehension or generator
expression.


Acknowledgements
================

The PEP author wishes to thank Chris Angelico for his work on PEP 572, and his
efforts to create a coherent summary of the great many sprawling discussions
that spawned on both python-ideas and python-dev, as well as Tim Peters for
the in-depth discussion of parent local scoping that prompted the above
scoping proposal for augmented assignments inside scoped expressions.

Eric Snow's feedback on a pre-release version of PEP 577 helped make it
significantly more readable, and then Guido van Rossum's review comments on
PEP 577 were one of the main drivers that led to it being withdrawn and this
proposal being made in its place.

Appendix A: Additional Examples from PEP 572
============================================

These examples come from Tim Peters' notes in PEP 572 Appendix A::

    if result := solution(xs, n) given result:
        # use result

::

    if reductor := dispatch_table.get(cls) given reductor:
        rv = reductor(x)
    elif reductor := getattr(x, "__reduce_ex__", None):
        rv = reductor(4)
    elif reductor := getattr(x, "__reduce__", None):
        rv = reductor()
    else:
        raise Error("un(shallow)copyable object of type %s" % cls)

::

    if (diff := x - x_base) and (g := gcd(diff, n)) > 1 given (diff, g):
        return g

::

    while a > (d := x // a**(n-1)) given d:
        a = ((n-1)*a + d) // n
    return a


References
==========

TODO: These are the same references as for PEP 577, but I haven't worked them
in to the text of the replacement PEP yet.

.. [1] The beginning of Tim's genexp & comprehension scoping thread
       (https://mail.python.org/pipermail/python-ideas/2018-May/050367.html)

.. [2] Reintroducing the original cumulative sums use case
       (https://mail.python.org/pipermail/python-ideas/2018-May/050544.html)

.. [3] Tim's language reference level explanation of his proposed scoping semantics
       (https://mail.python.org/pipermail/python-ideas/2018-May/050729.html)

.. [4] Guido's endorsement of Tim's proposed genexp & comprehension scoping
       (https://mail.python.org/pipermail/python-ideas/2018-May/050411.html)


Copyright
=========

This document has been placed in the public domain.



..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   coding: utf-8
   End:
